server.port=8080

security.basic.enabled=false

# [ DB Configruation Settings ]
spring.datasource.driver-class-name=org.postgresql.Driver
spring.jpa.database=POSTGRESQL
spring.datasource.platform=postgres
spring.datasource.test-on-borrow=true
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
spring.datasource.max-active=1

#spring.datasource.url=jdbc:postgresql://google/RecordTicker?cloudSqlInstance=grand-appliance-161222:us-east1:tickerrecords&socketFactory=com.google.cloud.sql.mysql.SocketFactory
#spring.datasource.url=jdbc:postgresql://35.227.107.199:5432/RecordTicke
#spring.datasource.url=jdbc:postgresql://google/RecordTicker?/socketFactory=com.google.cloud.sql.postgres.SocketFactory&socketFactoryArg=grand-appliance-161222:us-east1:tickerrecords
#spring.datasource.url=jdbc:postgresql://google/RecordTicker/TickRecords?cloudSqlInstance=grand-appliance-161222:us-east1:tickerrecords=com.google.cloud.sql.postgresql.SocketFactory
spring.datasource.url=jdbc:postgresql://recordticker.ckfgyptjuzew.us-east-1.rds.amazonaws.com:5432/RecordTicker
#spring.datasource.databaseName=postgres
spring.datasource.username=james
sprint.datasource.password=
spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults=false

# The next two lines are needed to ensure that you can use your tables as named - otherwise hibernate puts them into snake case
spring.jpa.hibernate.naming.implicit-strategy=org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
logging.level.org.hibernate=ERROR